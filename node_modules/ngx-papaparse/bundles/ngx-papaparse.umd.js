(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('papaparse/papaparse.min.js')) :
    typeof define === 'function' && define.amd ? define('ngx-papaparse', ['exports', '@angular/core', 'papaparse/papaparse.min.js'], factory) :
    (factory((global['ngx-papaparse'] = {}),global.ng.core,null));
}(this, (function (exports,core,lib) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var Papa = /** @class */ (function () {
        function Papa(config) {
            this.config = config;
            this._papa = lib;
            if (!this.config) {
                this.config = {};
            }
        }
        /**
         * Parse CSV to an array
         * @param {?} csv
         * @param {?=} config
         * @return {?}
         */
        Papa.prototype.parse = /**
         * Parse CSV to an array
         * @param {?} csv
         * @param {?=} config
         * @return {?}
         */
            function (csv, config) {
                if (config) {
                    if (config.worker === true) {
                        if (this.config.scriptPath) {
                            this._papa.SCRIPT_PATH = this.config.scriptPath;
                        }
                        else {
                            throw new Error('When using workers, the workerScriptPath must be defined in global' +
                                ' papaparse configuration. See' +
                                ' https://alberthaff.dk/projects/ngx-papaparse/docs/v3/parsing-csv/using-serviceworkers' +
                                ' for more information.');
                        }
                    }
                }
                return this._papa.parse(csv, config);
            };
        /**
         * Convert an array into CSV
         * @param {?} data
         * @param {?=} config
         * @return {?}
         */
        Papa.prototype.unparse = /**
         * Convert an array into CSV
         * @param {?} data
         * @param {?=} config
         * @return {?}
         */
            function (data, config) {
                return this._papa.unparse(data, config);
            };
        /**
         * Set the size in bytes of each file chunk.
         * Used when streaming files obtained from the DOM that
         * exist on the local computer. Default 10 MB.
         * @param {?} value
         * @return {?}
         */
        Papa.prototype.setLocalChunkSize = /**
         * Set the size in bytes of each file chunk.
         * Used when streaming files obtained from the DOM that
         * exist on the local computer. Default 10 MB.
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this._papa.LocalChunkSize = value;
            };
        /**
         * Set the size in bytes of each remote file chunk.
         * Used when streaming remote files. Default 5 MB.
         * @param {?} value
         * @return {?}
         */
        Papa.prototype.setRemoteChunkSize = /**
         * Set the size in bytes of each remote file chunk.
         * Used when streaming remote files. Default 5 MB.
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this._papa.RemoteChunkSize = value;
            };
        /**
         * Set the delimiter used when it is left unspecified and cannot be detected automatically. Default is comma.
         * @param {?} value
         * @return {?}
         */
        Papa.prototype.setDefaultDelimiter = /**
         * Set the delimiter used when it is left unspecified and cannot be detected automatically. Default is comma.
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this._papa.DefaultDelimiter = value;
            };
        Object.defineProperty(Papa.prototype, "badDelimiters", {
            /**
             * An array of characters that are not allowed as delimiters.
             */
            get: /**
             * An array of characters that are not allowed as delimiters.
             * @return {?}
             */ function () {
                return this._papa.BAD_DELIMITERS;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Papa.prototype, "recordSeperator", {
            /**
             * The true delimiter. Invisible. ASCII code 30.
             * Should be doing the job we strangely rely upon commas and tabs for.
             */
            get: /**
             * The true delimiter. Invisible. ASCII code 30.
             * Should be doing the job we strangely rely upon commas and tabs for.
             * @return {?}
             */ function () {
                return this._papa.RECORD_SEP;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Papa.prototype, "unitSeperator", {
            /**
             * Also sometimes used as a delimiting character. ASCII code 31.
             */
            get: /**
             * Also sometimes used as a delimiting character. ASCII code 31.
             * @return {?}
             */ function () {
                return this._papa.UNIT_SEP;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Papa.prototype, "workersSupported", {
            /**
             * Whether or not the browser supports HTML5 Web Workers.
             * If false, worker: true will have no effect.
             */
            get: /**
             * Whether or not the browser supports HTML5 Web Workers.
             * If false, worker: true will have no effect.
             * @return {?}
             */ function () {
                return this._papa.WORKERS_SUPPORTED;
            },
            enumerable: true,
            configurable: true
        });
        Papa.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        Papa.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: ['PapaParseGlobalConfig',] }] }
            ];
        };
        return Papa;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var PapaParseModule = /** @class */ (function () {
        function PapaParseModule() {
        }
        PapaParseModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        providers: [
                            Papa
                        ]
                    },] },
        ];
        return PapaParseModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.Papa = Papa;
    exports.PapaParseModule = PapaParseModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXBhcGFwYXJzZS51bWQuanMubWFwIiwic291cmNlcyI6WyJuZzovL25neC1wYXBhcGFyc2UvbGliL3BhcGEudHMiLCJuZzovL25neC1wYXBhcGFyc2UvbGliL3BhcGEtcGFyc2UubW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW5qZWN0LCBJbmplY3RhYmxlLCBPcHRpb25hbH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1BhcGFQYXJzZUdsb2JhbENvbmZpZ30gZnJvbSAnLi9pbnRlcmZhY2VzL3BhcGEtcGFyc2UtZ2xvYmFsLWNvbmZpZyc7XG5pbXBvcnQge1BhcGFQYXJzZVJlc3VsdH0gZnJvbSAnLi9pbnRlcmZhY2VzL3BhcGEtcGFyc2UtcmVzdWx0JztcbmltcG9ydCB7UGFwYVBhcnNlQ29uZmlnfSBmcm9tICcuL2ludGVyZmFjZXMvcGFwYS1wYXJzZS1jb25maWcnO1xuaW1wb3J0IHtQYXBhVW5wYXJzZUNvbmZpZ30gZnJvbSAnLi9pbnRlcmZhY2VzL3BhcGEtdW5wYXJzZS1jb25maWcnO1xuaW1wb3J0ICogYXMgbGliIGZyb20gJ3BhcGFwYXJzZS9wYXBhcGFyc2UubWluLmpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBhcGEge1xuICAgIHB1YmxpYyBfcGFwYSA9IGxpYjtcblxuICAgIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIEBJbmplY3QoJ1BhcGFQYXJzZUdsb2JhbENvbmZpZycpIHByaXZhdGUgY29uZmlnPzogUGFwYVBhcnNlR2xvYmFsQ29uZmlnXG4gICAgKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnID0ge307XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBDU1YgdG8gYW4gYXJyYXlcbiAgICAgKi9cbiAgICBwdWJsaWMgcGFyc2UoY3N2OiBzdHJpbmd8RmlsZSwgY29uZmlnPzogUGFwYVBhcnNlQ29uZmlnKTogUGFwYVBhcnNlUmVzdWx0IHtcbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy53b3JrZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcuc2NyaXB0UGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXBhLlNDUklQVF9QQVRIID0gdGhpcy5jb25maWcuc2NyaXB0UGF0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gdXNpbmcgd29ya2VycywgdGhlIHdvcmtlclNjcmlwdFBhdGggbXVzdCBiZSBkZWZpbmVkIGluIGdsb2JhbCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyBwYXBhcGFyc2UgY29uZmlndXJhdGlvbi4gU2VlJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGh0dHBzOi8vYWxiZXJ0aGFmZi5kay9wcm9qZWN0cy9uZ3gtcGFwYXBhcnNlL2RvY3MvdjMvcGFyc2luZy1jc3YvdXNpbmctc2VydmljZXdvcmtlcnMnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcGEucGFyc2UoY3N2LCBjb25maWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYW4gYXJyYXkgaW50byBDU1ZcbiAgICAgKi9cbiAgICBwdWJsaWMgdW5wYXJzZShkYXRhLCBjb25maWc/OiBQYXBhVW5wYXJzZUNvbmZpZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXBhLnVucGFyc2UoZGF0YSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNpemUgaW4gYnl0ZXMgb2YgZWFjaCBmaWxlIGNodW5rLlxuICAgICAqIFVzZWQgd2hlbiBzdHJlYW1pbmcgZmlsZXMgb2J0YWluZWQgZnJvbSB0aGUgRE9NIHRoYXRcbiAgICAgKiBleGlzdCBvbiB0aGUgbG9jYWwgY29tcHV0ZXIuIERlZmF1bHQgMTAgTUIuXG4gICAgICovXG4gICAgcHVibGljIHNldExvY2FsQ2h1bmtTaXplKHZhbHVlOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcGFwYS5Mb2NhbENodW5rU2l6ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2l6ZSBpbiBieXRlcyBvZiBlYWNoIHJlbW90ZSBmaWxlIGNodW5rLlxuICAgICAqIFVzZWQgd2hlbiBzdHJlYW1pbmcgcmVtb3RlIGZpbGVzLiBEZWZhdWx0IDUgTUIuXG4gICAgICovXG4gICAgcHVibGljIHNldFJlbW90ZUNodW5rU2l6ZSh2YWx1ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3BhcGEuUmVtb3RlQ2h1bmtTaXplID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBkZWxpbWl0ZXIgdXNlZCB3aGVuIGl0IGlzIGxlZnQgdW5zcGVjaWZpZWQgYW5kIGNhbm5vdCBiZSBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5LiBEZWZhdWx0IGlzIGNvbW1hLlxuICAgICAqL1xuICAgIHB1YmxpYyBzZXREZWZhdWx0RGVsaW1pdGVyKHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcGFwYS5EZWZhdWx0RGVsaW1pdGVyID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgYWxsb3dlZCBhcyBkZWxpbWl0ZXJzLlxuICAgICAqL1xuICAgIGdldCBiYWREZWxpbWl0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFwYS5CQURfREVMSU1JVEVSUztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHJ1ZSBkZWxpbWl0ZXIuIEludmlzaWJsZS4gQVNDSUkgY29kZSAzMC5cbiAgICAgKiBTaG91bGQgYmUgZG9pbmcgdGhlIGpvYiB3ZSBzdHJhbmdlbHkgcmVseSB1cG9uIGNvbW1hcyBhbmQgdGFicyBmb3IuXG4gICAgICovXG4gICAgZ2V0IHJlY29yZFNlcGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcGEuUkVDT1JEX1NFUDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbHNvIHNvbWV0aW1lcyB1c2VkIGFzIGEgZGVsaW1pdGluZyBjaGFyYWN0ZXIuIEFTQ0lJIGNvZGUgMzEuXG4gICAgICovXG4gICAgZ2V0IHVuaXRTZXBlcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXBhLlVOSVRfU0VQO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIHN1cHBvcnRzIEhUTUw1IFdlYiBXb3JrZXJzLlxuICAgICAqIElmIGZhbHNlLCB3b3JrZXI6IHRydWUgd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAgICAgKi9cbiAgICBnZXQgd29ya2Vyc1N1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcGEuV09SS0VSU19TVVBQT1JURUQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7UGFwYX0gZnJvbSAnLi9wYXBhJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgUGFwYVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgUGFwYVBhcnNlTW9kdWxlIHsgfVxuIl0sIm5hbWVzIjpbIkluamVjdGFibGUiLCJPcHRpb25hbCIsIkluamVjdCIsIk5nTW9kdWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7UUFXSSxjQUFpRSxNQUE4QjtZQUE5QixXQUFNLEdBQU4sTUFBTSxDQUF3Qjt5QkFGaEYsR0FBRztZQUlkLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUNkLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO2FBQ3BCO1NBQ0o7Ozs7Ozs7UUFLTSxvQkFBSzs7Ozs7O3NCQUFDLEdBQWdCLEVBQUUsTUFBd0I7Z0JBQ25ELElBQUksTUFBTSxFQUFFO29CQUNSLElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxJQUFJLEVBQUU7d0JBQ3hCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUU7NEJBQ3hCLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDO3lCQUNuRDs2QkFBTTs0QkFDSCxNQUFNLElBQUksS0FBSyxDQUFDLG9FQUFvRTtnQ0FDaEYsK0JBQStCO2dDQUMvQix3RkFBd0Y7Z0NBQ3hGLHdCQUF3QixDQUFDLENBQUM7eUJBQ2pDO3FCQUNKO2lCQUNKO2dCQUVELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDOzs7Ozs7OztRQU1sQyxzQkFBTzs7Ozs7O3NCQUFDLElBQUksRUFBRSxNQUEwQjtnQkFDM0MsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7Ozs7Ozs7OztRQVFyQyxnQ0FBaUI7Ozs7Ozs7c0JBQUMsS0FBYTtnQkFDbEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLEdBQUcsS0FBSyxDQUFDOzs7Ozs7OztRQU8vQixpQ0FBa0I7Ozs7OztzQkFBQyxLQUFhO2dCQUNuQyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsR0FBRyxLQUFLLENBQUM7Ozs7Ozs7UUFNaEMsa0NBQW1COzs7OztzQkFBQyxLQUFhO2dCQUNwQyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixHQUFHLEtBQUssQ0FBQzs7UUFNeEMsc0JBQUksK0JBQWE7Ozs7Ozs7Z0JBQWpCO2dCQUNJLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUM7YUFDcEM7OztXQUFBO1FBTUQsc0JBQUksaUNBQWU7Ozs7Ozs7OztnQkFBbkI7Z0JBQ0ksT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQzthQUNoQzs7O1dBQUE7UUFLRCxzQkFBSSwrQkFBYTs7Ozs7OztnQkFBakI7Z0JBQ0ksT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQzthQUM5Qjs7O1dBQUE7UUFNRCxzQkFBSSxrQ0FBZ0I7Ozs7Ozs7OztnQkFBcEI7Z0JBQ0ksT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDO2FBQ3ZDOzs7V0FBQTs7b0JBMUZKQSxlQUFVOzs7Ozt3REFJTUMsYUFBUSxZQUFJQyxXQUFNLFNBQUMsdUJBQXVCOzs7bUJBWDNEOzs7Ozs7O0FDQUE7Ozs7b0JBR0NDLGFBQVEsU0FBQzt3QkFDTixPQUFPLEVBQUUsRUFBRTt3QkFDWCxTQUFTLEVBQUU7NEJBQ1AsSUFBSTt5QkFDUDtxQkFDSjs7OEJBUkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==